generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Instance {
  id            Int    @id @default(autoincrement())
  applicationId String @unique @map("application_id")
  token         String @unique
  publicKey     String @unique @map("public_key")

  isPublic Boolean @default(false) @map("is_public")
  isActive Boolean @map("is_active")

  expiresAt DateTime? @map("expires_at")
  createdAt DateTime  @default(now()) @map("created_at")
  updatedAt DateTime  @updatedAt @map("updated_at")

  instanceGuilds InstanceGuild[]
  guildConfigs   GuildConfig[]

  @@map("Instances")
}

// TODO: is this even really needed?
model InstanceGuild {
  id              Int     @id @default(autoincrement())
  applicationId   String  @map("application_id")
  // FIXME: this is here for convenience. is there a better way to use nested
  // applicationId Int @map("application_id")
  guildId         String  @map("guild_id")
  accessGrantedBy String? @map("access_granted_by")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  instance Instance @relation(fields: [applicationId], references: [applicationId], onDelete: Cascade)

  // @@unique([instanceId, guildId])
  @@unique([applicationId, guildId])
  @@map("InstanceGuilds")
}

// TODO: isPremium? or premium table
model GuildConfig {
  id            Int    @id @default(autoincrement())
  applicationId String @map("application_id")
  guildId       String @map("guild_id")

  locale     String
  flags      Int      @default(0)
  adminRoles String[] @map("admin_roles")
  staffRoles String[] @map("staff_roles")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  instance       Instance         @relation(fields: [applicationId], references: [applicationId], onDelete: Cascade)
  SuggestionFeed SuggestionFeed[]

  @@unique([applicationId, guildId])
  @@map("GuildConfigs")
}

model SuggestionFeed {
  id            Int    @id @default(autoincrement())
  applicationId String @map("applicationId")
  guildId       String @map("guild_id")

  name             String?
  description      String?
  // TODO: make this unique if not null
  commandAliasName String? @map("command_alias_name")

  channelId        String  @map("channel_id")
  reviewChannelId  String? @map("review_channel_id")
  logChannelId     String? @map("log_channel_id")
  deniedChannelId  String? @map("denied_channel_id")
  archiveChannelId String? @map("archive_channel_id")

  mode SuggestionFeedMode @default(AUTOAPPROVE)

  // roles allowed to vote
  votingRoles  String[] @map("voting_roles")
  // roles allowed to submit stuff to this feed
  allowedRoles String[] @map("allowed_roles")
  // roles not allowed to submit stuff to this feed
  blockedRoles String[] @map("blocked_roles")

  // TODO: what do these do?
  pingRole     String? @map("ping_role")
  feedPingRole String? @map("feed_ping_role")

  // role given when user has suggestion approved
  approvedRole    String? @map("approved_role")
  // role given when user has suggestion implemented
  implementedRole String? @map("implemented_role")

  upvoteEmoji   String? @map("upvote_emoji")
  midEmoji      String? @map("mid_emoji")
  downvoteEmoji String? @map("downvote_emoji")

  logWebhookId    String? @map("log_webhook_id")
  logWebhookToken String? @map("log_webhook_token")

  // how often users can submit
  submitCooldown Int? @map("submit_cooldown")
  suggestionCap  Int? @map("suggestion_cap")

  showCommentTimestamps Boolean @default(true) @map("show_comment_timestamps")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  guildConfig GuildConfig @relation(fields: [applicationId, guildId], references: [applicationId, guildId], onDelete: Cascade)

  suggestions Suggestion[]

  @@unique([applicationId, guildId, channelId])
  @@map("SuggestionFeeds")
}

model Suggestion {
  id            Int    @id @default(autoincrement())
  applicationId String @map("applicationId")
  guildId       String @map("guild_id")
  feedChannelId String @map("feed_channel_id")
  authorId      String @map("author_id")

  // this field is automatically set by a trigger in the datebase (see bottom of file)
  // however, prisma will complain if we don't provide a value for it, so setting default to 0 works
  suggestionId  Int     @default(0) @map("suggestion_id")
  feedMessageId String? @map("feed_message_id")

  body           String
  approvalStatus SuggestionApprovalStatus
  displayStatus  SuggestionDisplayStatus  @default(DEFAULT)

  denialReason String? @map("denial_reason")

  attachmentURL      String? @map("attachment_url")
  trelloAttachmentId String? @map("trello_attachment_id")

  trelloCard String? @map("trello_card")

  pendingEditBody      String?   @map("pending_edit_body")
  pendingEditCreatedAt DateTime? @default(now()) @map("pending_edit_created_at")

  lastEditedBy String? @map("last_modified_by")
  isAnonymous  Boolean @default(false) @map("is_anonymous")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  feed          SuggestionFeed           @relation(fields: [feedChannelId, applicationId, guildId], references: [channelId, applicationId, guildId], onDelete: Cascade)
  comments      SuggestionComment[]
  votes         SuggestionVote[]
  subscriptions SuggestionSubscription[]

  @@unique([feedChannelId, suggestionId])
  @@map("Suggestions")
}

model SuggestionComment {
  id           Int    @id @default(autoincrement())
  suggestionId Int    @map("suggestion_id")
  authorId     String @map("author_id")
  // TODO: figure out how to generate this
  commentId    Int    @map("comment_id")

  body          String
  trelloComment String? @map("trello_comment")
  isAnonymous   Boolean @default(false) @map("is_anonymous")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  suggestion Suggestion @relation(fields: [suggestionId], references: [id], onDelete: Cascade)

  @@map("SuggestionComments")
}

model SuggestionVote {
  id           Int    @id @default(autoincrement())
  suggestionId Int    @map("suggestion_id")
  userId       String @map("user_id")

  kind SuggestionVoteKind

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  suggestion Suggestion @relation(fields: [suggestionId], references: [id], onDelete: Cascade)

  @@map("SuggestionVotes")
}

model SuggestionSubscription {
  id           Int    @id @default(autoincrement())
  suggestionId Int    @map("suggestion_id")
  userId       String @map("user_id")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  suggestion Suggestion @relation(fields: [suggestionId], references: [id], onDelete: Cascade)

  @@unique([suggestionId, userId])
  @@map("SuggestionSubscriptions")
}

model GlobalUser {
  id     Int    @id @default(autoincrement())
  userId String @map("user_id")

  // TODO: en-US the correct name?
  locale        String   @default("en-US")
  flags         Int      @default(0)
  showProtips   Boolean  @default(true) @map("show_protips")
  protipsViewed String[] @map("protips_viewed")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("GlobalUsers")
}

model GlobalBlock {
  id        Int     @id @default(autoincrement())
  entityId  String  @map("entity_id")
  blockedBy String? @map("blocked_by")

  kind   GlobalBlockKind
  reason String?

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@unique([entityId, kind])
  @@map("GlobalBlocks")
}

enum SuggestionFeedMode {
  AUTOAPPROVE
  REVIEW
}

enum SuggestionApprovalStatus {
  APPROVED
  IN_QUEUE
  DENIED
}

enum SuggestionDisplayStatus {
  DEFAULT
  IMPLEMENTED
  CONSIDERING
  IN_PROGRESS
  NOT_HAPPENING
}

enum SuggestionVoteKind {
  UPVOTE
  MID
  DOWNVOTE
}

enum GlobalBlockKind {
  USER
  GUILD
}

// postgres function for generating automatically incrementing suggestion IDs:

// DROP TRIGGER IF EXISTS generate_suggestion_id ON "Suggestions";
// DROP FUNCTION IF EXISTS generate_suggestion_id;

// CREATE FUNCTION generate_suggestion_id() RETURNS TRIGGER AS $$
// BEGIN
//   SELECT (COALESCE(MAX(id), 0) + 1)
//   INTO NEW.id
//   FROM "Suggestions"
//   WHERE feed_id = NEW.feed_id;
//   RETURN NEW;
// END;
// $$ LANGUAGE plpgsql;

// CREATE TRIGGER generate_suggestion_id
// BEFORE INSERT
// ON "Suggestions"
// FOR EACH ROW
// EXECUTE PROCEDURE generate_suggestion_id();

// vim:si
